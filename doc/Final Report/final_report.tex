% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point
% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file.
% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the
% usepackage command, below.
% This version uses the latex2e styles, not the very ancient 2.09 stuff.
\documentclass[letterpaper,10pt]{article}
%\usepackage{usenix,epsfig,endnotes}
\usepackage{fullpage,epsfig,endnotes,mathtools}
\begin{document}
%make title bold and 14 pt font (Latex default is non-bold, 16 pt}

\title{\Large \bf 18-545: OpenGL Graphics Acelerator}
%for single author (just remove % characters)
\author{
{\rm Andrew J.\ Lau, Alan X.\ Zhu, and Nathan L.\ Wan}\\
\{ajlau, axz, nlw\}@andrew.cmu.edu\\
Carnegie Mellon University
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\date{December 8, 2010}

\maketitle
\newpage
\tableofcontents
\listoffigures
\listoftables
\newpage
% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}

\section{Introduction}
This report discusses an OpenGL graphics accelerator implemented on a Xilinx XUPV5-LX110T FPGA during the Fall 2010 iteration of the Advanced Digital Design capstone course at Carnegie Mellon University. We cover the overall system design, implementation details, and advice for adding further functionality to the system in the future.

\section{System Overview}
The graphics accelerator can be broken down into five major components:
\begin{enumerate}

\item Perl Parser

\item Instruction Assembler

\item Instruction Cache

\item Coordinate Transformation Pipeline

\item Rasterization Unit

\item Framebuffer/Display

\end{enumerate}
<insert system diagram here>

\section{System Specification}
\subsection{Hardware}
\begin{itemize}

\item Microblaze processor

\item Floating point units

\item Coordinate Transformation Pipeline

\item Rasterization Unit

\item Instruction Cache

\item FIFOs

\item Framebuffer Controller

\end{itemize}

\subsection{Software}
\begin{itemize}

\item Perl Parser

\item Instruction Assembler (running on Microblaze)

\end{itemize}

\subsection{Development Software}
\begin{itemize}

\item Xilinx ISE Design Suite 12.2

\item Git

\item Windows XP

\item Ubuntu

\end{itemize}

\section{OpenGL}
\subsection{Rationale}
We chose to implement an OpenGL pipeline because it is a well known industry standard for 2D/3D graphics. In addition, the pipeline design itself is well documented with numerous existing implementations in both hardware and software.

\subsection{Supported Functions}

\subsection{Interface to Pipeline}

\subsubsection{Perl Parser}
In order for the pipeline to accept graphical language calls, a Perl script was written that takes human readable trace of OpenGL calls and outputs a hex representation of the program. 

The trace is generated from simple hand-generated C programs. Conditionals, loops, and variables are unrolled and substituted so that what remains is strictly OpenGL calls and data in the form of actual numeric values. These traces correspond to the calls that would be made by a C library such as GLSim.

The main function of the script is to parse each GL call, generate a 32-bit hex value that corresponds to the instruction code defined in the ISA, and output the hex value to a file. If there are argument parameters in the call, each parameter is translated into its hex representation and printed on subsequent lines in the file. The output is an OPNGG hex file (*.gg). Each line of the file is one hex value, either corresponding to an instruction call or one of several 32-bit arguments encoded in hex (single precision floating point , unsigned integer, etc.)

\subsubsection{Instruction Assembler}
\section{Instruction Set Architecture}

\subsection{Specification}

The ISA defines a 32-bit instruction word to align with the width of single precision floating point word. The \emph{opcode} field is 8 bits wide, allowing support for up to 256 different routines. This is leaves plenty for room for extending the pipeline to support other some of the 300+ OpenGL calls, as only 17 slots are filled in the current state. The fetch unit addresses the instruction cache at a 32-bit granularity.

\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | l | l | l |}
\hline
Bits & [31] & [30:8] & [7:0] \\ \hline
Content & Type & Data & Opcode \\ \hline
\end{tabular}
\end{center}
\caption{Instruction word}
\end{table}

Each supported function is translated by the Perl parser into the follow instruction words. The \emph{data} field indicates to the fetch unit to expect a certain number of floats following the instruction word if the \emph{type} field is set. 

\begin{table}[htbp]
\begin{center}
\begin{tabular}{ | l | l | l | l |}
\hline
Function & Type & Data & Opcode \\ \hline
glBegin (void) & 0 & X & 00000001 \\ \hline
glEnd (void) & 0 & X & 00000010 \\ \hline
glVertex (float x, float y, float z) & 1 & 3 & 00000011 \\ \hline
glColor (float r, float g, float b) & 1 & 3 & 00000100 \\ \hline
glFlush (void) & 0 & X & 00000101 \\ \hline
glMatrixMode (enum mode) & 0 & imm & 00010000 \\ \hline
glMultMatrix (const float *m) & 0 & 16 & 00010001 \\ \hline
glLoadIdentity (void) & 0 & X & 00010010 \\ \hline
glLoadMatrix (const float *m) & 1 & 16 & 00010011 \\ \hline
glPushMatrix (void) & 0 & X & 00010100 \\ \hline
glPopMatrix (void) & 0 & X & 00010101 \\ \hline
glRotate (float angle, float x, float y, float z) & 1 & 4 & 00010110 \\ \hline
glScale (float x, float y, float z) & 1 & 3 & 00010111 \\ \hline
glTranslate (float x, float y, float z) & 1 & 3 & 00011000 \\ \hline
glViewport (int x, int y, int width, int height) & 1 & 4 & 00011001 \\ \hline
glFrustum (int left, int right, int bottom, int top, int near, int far) & 1 & 6 & 00011010 \\ \hline
glOrtho (int left, int right, int bottom, int top, int near, int far) & 1 & 6 & 00011011 \\ \hline
\end{tabular}
\end{center}
\caption{OpenGL routine to opcode mappings}
\end{table}

\section{Fetch and Decode}
\subsection{Instruction Cache}
The instruction cache consists of 512 entries of 32-bit words and supports 5 reads and 1 write - concurrently serving the fetch, decode, and instruction assembler through a BRAM controller on the PLB. It is currently implemented in logic, with a combinational read. Further work would be needed to move the instruction cache into block RAM, requiring a clocked read.

\subsection{Fetch Unit}
The fetch unit reads one 32-bit word per cycle from the instruction cache, stalling if the vertex and color FIFOs are full and during matrix operations.

\subsection{Decode Unit}
The decode unit generates control signals for the matrix stacks, matrix multipliers, perspective division, and viewport transformation. It also reads 4 32-bit words from the instruction cache for use in the latter pipeline stages.

\section{Matrix Operations}
The pipeline implements two 16x16 matrix stacks
\subsection{â€¢}

\section{Coordinate Transformation}
Each vertex that gets passed into Coordinate Transformation goes through a series of transformations so that it ends up in the correct range to be displayed on the screen.

\subsection{Eye Coordinates}


\subsection{Perspective Division}
Perspective division yields coordinates known as \emph{normalized device coordinates}, with their range normalized to $(-1,1)$ for all 3 axes.\\
\begin{figure}[h]
\[
\begin{pmatrix}
x_{ndc} \\
y_{ndc} \\
z_{ndc}
\end{pmatrix}
= M_{projection} \cdot
\begin{pmatrix}
x_{clip}/w_{clip} \\
y_{clip}/w_{clip} \\
z_{clip}/w_{clip}
\end{pmatrix}
\]
\caption{Perspective Division}
\end{figure}

\subsection{Viewport Transformation}
Viewport transformation scales and translates the \emph{normalized device coordinates} to fit the rendering screen. The results $(x_{w},y_{w},z_{w})$ are passed to the rasterizer. The transformation is given by: \\
\begin{figure}[h]
\[
\begin{pmatrix}
x_{w} \\
y_{w} \\
z_{w}
\end{pmatrix}
=
\begin{pmatrix}
\frac{w}{2}x_{ndc}+(x+\frac{w}{2}) \\
\frac{h}{2}y_{ndc}+(y+\frac{h}{2})  \\
\frac{f-n}{2}z_{ndc}+\frac{f+n}{2}
\end{pmatrix}
\]
\caption{Viewport Transformation}
\end{figure}\\
With some factoring, this is implemented using three floating point multipliers and five floating point adders.

\section{Rasterization}
\subsection{Bounding Box}
\subsection{Horizontal Scanline}
\subsection{Color Interpolation}

\section{Framebuffer/DVI Controller}

\subsection{DVI Controller}

The reference design for the XUPV5 contained a DVI controller that displays a frame buffer on DDR2 SDRAM.  The core outputs a 640 by 480 video over the DVI port of the board.  The core reads a line of the SDRAM frame buffer over the PLB bus and stores it locally in BRAM. Since the frame buffer is any 2MB region in the PLB address space, the frame buffer does not actually have to reside in SDRAM.  Any mapped address can be used as a frame buffer, which demonstrates some of the flexibility of the PLB.  The DVI controller has control registers mapped on the DCR bus interface.  In order for other elements in the system to configure the controller, there is a PLB/DCR bridge.


\subsection{PLB IPIF}

Using the PLB actually offered great flexibility in the interconnect of cores.  Although it restricted the project in some ways, requiring the use of particular 

\subsection{DMA}


\section{Major Design Decisions}
\subsection{Floating Point vs. Fixed Point}
\subsection{Synchronization}
\subsection{External Cores}
It soon became apparent we could not do everything. The decision to conform to the Xilinx tool chain was 


\section{Individual Contributions}
\subsection{Andrew Lau}
My primary responsibilities for this project were the implementation of the vertex transformation pipeline and the integration and testing of the various parts of the pipeline. The first few weeks of the project were spent working closely with Alan to design the front end of the pipeline, specifically how to use GLSim to talk to the pipeline. This idea was quickly squashed as we found that GLSim was deprecated and had not been updated since 2002. 
\subsection{Alan Zhu}
\subsection{Nathan Wan}

\section{Status and Future Work}
\subsection{Tool Chain}
\subsection{CPU Integration}
\subsection{Shader}
\subsection{MPMC}
\subsection{vsync Timing}

\section{Class Impression/Improvements}

\subsection{Tool Chain Frustration}
\subsection{Too much Independence / No Feedback}

\end{document}