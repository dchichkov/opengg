% TEMPLATE for Usenix papers, specifically to meet requirements of
%  USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
%   written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
%   Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
%   both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point
% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file.
% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the
% usepackage command, below.
% This version uses the latex2e styles, not the very ancient 2.09 stuff.
\documentclass[letterpaper,10pt]{article}
%\usepackage{usenix,epsfig,endnotes}
\usepackage{fullpage,epsfig,endnotes,mathtools}
\begin{document}
%make title bold and 14 pt font (Latex default is non-bold, 16 pt}

\title{\Large \bf 18-545: OpenGL Graphics Acelerator}
%for single author (just remove % characters)
\author{
{\rm Andrew J.\ Lau, Alan X.\ Zhu, and Nathan L.\ Wan}\\
\{ajlau, axz, nlw\}@andrew.cmu.edu\\
Carnegie Mellon University
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\date{December 8, 2010}

\maketitle
\newpage
\tableofcontents
\listoffigures
\listoftables
\newpage
% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}

\section{Introduction}
This report discusses an OpenGL graphics accelerator implemented on a Xilinx XUPV5-LX110T FPGA during the Fall 2010 iteration of the Advanced Digital Design capstone course at Carnegie Mellon University. We cover the overall system design, implementation details, and advice for adding further functionality to the system in the future.

\section{System Overview}
The graphics accelerator can be broken down into five major components:
\begin{enumerate}

\item Perl Parser

\item Instruction Assembler

\item Instruction Cache

\item Coordinate Transformation Pipeline

\item Rasterization Unit

\item Framebuffer/Display

\end{enumerate}
<insert system diagram here>

\section{System Specification}
\subsection{Hardware}
\begin{itemize}

\item Microblaze processor

\item Floating point units

\item Coordinate Transformation Pipeline

\item Rasterization Unit

\item Instruction Cache

\item FIFOs

\item Framebuffer Controller

\end{itemize}

\subsection{Software}
\begin{itemize}

\item Perl Parser

\item Instruction Assembler (running on Microblaze)

\end{itemize}

\subsection{Development Software}
\begin{itemize}

\item Xilinx ISE Design Suite 12.2

READ: OS and Libraries Document Collection and EDK Concept, Tools, and Techniques

\item Git

\item Windows XP

\item Ubuntu

Initially, wanted machine to be primary machine for development.  Unfortunately, the usb drivers for the JTAG cable never came into fruition, so board programming was relegated to the Windows machine.  Much of the simulation and core development still happened on the Ubuntu box.  Also held a git repository that was later moved to github.  It was used as an easy way to transfer files between group members because Windows networked file system is unusable.  

\end{itemize}

\section{OpenGL}
\subsection{Rationale}
We chose to implement an OpenGL pipeline because it is a well known industry standard for 2D/3D graphics. In addition, the pipeline design itself is well documented with numerous existing implementations in both hardware and software.

\subsection{Supported Functions}

\subsection{Interface to Pipeline}

\subsubsection{Perl Parser}
In order for the pipeline to accept graphical language calls, a Perl script was written that takes human readable trace of OpenGL calls and outputs a hex representation of the program. \\

The trace is generated from simple hand-generated C programs. Conditionals, loops, and variables are unrolled and substituted so that what remains is strictly OpenGL calls and data in the form of actual numeric values. These traces correspond to the calls that would be made by a C library such as GLSim.\\

The main function of the script is to parse each GL call, generate a 32-bit hex value that corresponds to the instruction code defined in the ISA, and output the hex value to a file. If there are argument parameters in the call, each parameter is translated into its hex representation and printed on subsequent lines in the file. The output is an OPNGG hex file (*.gg). Each line of the file is one hex value, either corresponding to an instruction call or one of several 32-bit arguments encoded in hex (single precision floating point , unsigned integer, etc.)

\subsubsection{Instruction Assembler}
The Microblaze processor is critical for programming the accelerator.  To program the instruction cache, the Microblaze reads off a file containing the graphical program and copies in data.  The file resides on the Compact Flash and its format guaranteed by the Perl Parser; the assembler does not check the format of the executable.  The SDK's XilFATFS is a library that allows the Microblaze to read files on the Compact Flash.  For the most part, it follows the C convention for file handling.  The instruction BRAM has an interface identical to that of the Xilinx BRAM cores.  This is so that a PLB to BRAM interface core, provided by Xilinx, can be used to allow the Microblaze to write directly into our module's BRAM.  


\section{Instruction Set Architecture}

\subsection{Specification}

The ISA defines a 32-bit instruction word to align with the width of single precision floating point word. The \emph{opcode} field is 8 bits wide, allowing support for up to 256 different routines. This is leaves plenty for room for extending the pipeline to support other some of the 300+ OpenGL calls, as only 17 slots are filled in the current state. The fetch unit addresses the instruction cache at a 32-bit granularity.

\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | l | l | l |}
\hline
Bits & [31] & [30:8] & [7:0] \\ \hline
Content & Type & Data & Opcode \\ \hline
\end{tabular}
\end{center}
\caption{Instruction word}
\end{table}

Each supported function is translated by the Perl parser into the follow instruction words. The \emph{data} field indicates to the fetch unit to expect a certain number of floats following the instruction word if the \emph{type} field is set.

\begin{table}[h]
\begin{center}
\begin{tabular}{ | l | l | l | l |}
\hline
Function & Type & Data & Opcode \\ \hline
glBegin (void) & 0 & X & 00000001 \\ \hline
glEnd (void) & 0 & X & 00000010 \\ \hline
glVertex (float x, float y, float z) & 1 & 3 & 00000011 \\ \hline
glColor (float r, float g, float b) & 1 & 3 & 00000100 \\ \hline
glFlush (void) & 0 & X & 00000101 \\ \hline
glMatrixMode (enum mode) & 0 & imm & 00010000 \\ \hline
glMultMatrix (const float *m) & 0 & 16 & 00010001 \\ \hline
glLoadIdentity (void) & 0 & X & 00010010 \\ \hline
glLoadMatrix (const float *m) & 1 & 16 & 00010011 \\ \hline
glPushMatrix (void) & 0 & X & 00010100 \\ \hline
glPopMatrix (void) & 0 & X & 00010101 \\ \hline
glRotate (float angle, float x, float y, float z) & 1 & 4 & 00010110 \\ \hline
glScale (float x, float y, float z) & 1 & 3 & 00010111 \\ \hline
glTranslate (float x, float y, float z) & 1 & 3 & 00011000 \\ \hline
glViewport (int x, int y, int width, int height) & 1 & 4 & 00011001 \\ \hline
glFrustum (int left, int right, int bottom, int top, int near, int far) & 1 & 6 & 00011010 \\ \hline
glOrtho (int left, int right, int bottom, int top, int near, int far) & 1 & 6 & 00011011 \\ \hline
\end{tabular}
\end{center}
\caption{OpenGL routine to opcode mappings}
\end{table}

\section{Coordinate Transformation}
\subsection{Matrix Operations}

\subsection{Perspective Division}

\subsection{Viewport Transformation}
Viewport transformation scales and translates the normalized device coordinates to fit the rendering screen. The results $(x_{w},y_{w},z_{w})$ are passed to the rasterizer. The transformation is given by: \\
\begin{figure}[h]
\[
\begin{pmatrix}
x_{w} \\
y_{w} \\
z_{w}
\end{pmatrix}
=
\begin{pmatrix}
\frac{w}{2}x_{ndc}+(x+\frac{w}{2}) \\
\frac{h}{2}y_{ndc}+(y+\frac{h}{2})  \\
\frac{f-n}{2}z_{ndc}+\frac{f+n}{2}
\end{pmatrix}
\]
\caption{Viewport Transformation}
\end{figure}\\
With some factoring, this is implemented using three floating point multipliers and five floating point adders.

\section{Rasterization}
\subsection{Bounding Box}
\subsection{Horizontal Scanline}
\subsection{Color Interpolation}

\section{Framebuffer/DVI Controller}

\subsection{DVI Controller}

The reference design for the XUPV5 contained a DVI controller that displays a frame buffer on DDR2 SDRAM.  The core outputs a 640 by 480 video over the DVI port of the board.  The core reads a line of the SDRAM frame buffer over the PLB bus and stores it locally in BRAM. Since the frame buffer is any 2MB region in the PLB address space, the frame buffer does not actually have to reside in SDRAM.  Any mapped address can be used as a frame buffer, which demonstrates some of the flexibility of the PLB.  The DVI controller has control registers mapped on the DCR bus interface.  In order for other elements in the system to configure the controller, there is a PLB/DCR bridge what maps the DCR space to a part of the system PLB address space.


\subsection{PLB IPIF}

Using the PLB actually offered great flexibility in the interconnect of cores.  Although it restricted the project in some ways, requiring the use of particular 

\subsection{DMA}


\section{Major Design Decisions}
\subsection{Floating Point vs. Fixed Point}
\subsection{Synchronization}
\subsection{External Cores}

It soon became apparent we could not do everything. The decision to conform to the Xilinx tool chain stemmed partially from the convenience of provided Xilinx cores and generated cores from CoreGEN.  The framework provided by the Xilinx EDK had some advantages.  It has a way to run C code a soft processor, the Microblaze.  It provides the interconnecting bus structure, PLB.  The reference design also contains the Multi-Port Memory Controller (MPMC) which provides an accessible interface for the DD2 SDRAM.  

\subsubsection{CoreGEN}
CoreGEN allows us to generate different types of modules.  It is a tool provided by Xilinx included in their design suite and provides blackbox *.v and *.ngc files for usage in your projects.  They provide a variety different, commonly used cores, that is, if it is not a custom type of hardware, you can probably find it in CoreGEN.  Most of the modules in the reference design actually comes from CoreGEN, including the versatile MPMC.  The floating point units used throughout our design were generated to specific parameters.  It was useful to specify usage of DSP48E slices instead of logic slices.  CoreGEN also allowed us to specify latency, which became extremely important.  The FIFO's were also generated by CoreGEN.  It was nice to be able to specify what kind of hardware resources each would consume, whether Block RAM, Distributed RAM or built-in units.  Note that the built-in units may not simulate as easily; simply generate Block RAM modules for simulation and regenerate the cores with the same project file when moving back to synthesis.


\section{Individual Contributions}
\subsection{Andrew Lau}
My primary responsibilities for this project were the implementation of the vertex transformation pipeline and the integration and testing of the various parts of the pipeline. The first few weeks of the project were spent working closely with Alan to design the front end of the pipeline, specifically how to use GLSim to talk to the pipeline. This idea was quickly squashed as we found that GLSim was deprecated and had not been updated since 2002. \\

\subsection{Alan Zhu}
\subsection{Nathan Wan}

One Man Tools Team
Web/SDK work
PLB and System Design

\section{Status and Future Work}
\subsection{Tool Chain}
\subsection{CPU Integration}
\subsection{Shader}
A very interesting project would be to work on a graphics shader.  OpenGL ES 2.0 relies primary on the shader to replace many fixed function units in the pipeline.  

\subsection{MPMC}
\subsection{vsync Timing}

\section{Class Impression/Improvements}

\subsection{Tool Chain Frustration}
\subsection{Too much Independence / No Feedback}

\end{document}